# Updating a contract

In this example we will use TON contract update functionality to modify the logic of already deployed contract.

1. We will deploy the initail counter contract:

```tact
contract CounterBeforeUpdate(
    data: Int as uint32,
    updateAuthority: Address,
) {
    receive(msg: CounterAction) {
        self.data += 1;
    }

    receive(msg: UpdateContractRequest) {
        require(sender() == self.updateAuthority, "Incorrect update authority");
        setData(msg.data);
        setCode(msg.code);
    }

    get fun data(): Int {
        return self.data;
    }
}
```

Its storage contains two fields, counter data and update authority. Upon receiving `CounterAction` message, this contract increases its internal `data` variable.

2. We will prepare and compile the second counter contract:

```tact
contract CounterAfterUpdate(
    data: Int as uint32,
) {
    receive(msg: CounterAction) {
        self.data -= 1;
    }

    get fun data(): Int {
        return self.data;
    }
}
```

This contract has only one field, integer `data` variable. Also, this contract *decreases* counter variable upon receiving the same `CounterAction` message.

3. Now we want to use `UpdateContractRequest` message on deployed contract to update its code and data. Message itself looks like this:

```tact
message(0xa7ffd45e) UpdateContractRequest {
    code: Cell;
    data: Cell;
}
```

The most optimal way to create such a message is to use Tact autogenerated wrapper for `CounterAfterUpdate`. After initiating it with needed parameters, we can extract code and data from it:

```ts
import {CounterAfterUpdate} from "../output/UpdateContract_CounterAfterUpdate"
// ...
const firstCounterValue = await initialCounterContract.getData()

const newCounterContractState = await CounterAfterUpdate.fromInit(firstCounterValue)
const updateResult = await initialCounterContract.send(
    deployer.getSender(),
    {value: toNano("0.1")},
    {
        $$type: "UpdateContractRequest",
        code: newCounterContractState.init?.code!,
        data: newCounterContractState.init?.data!,
    },
)
```

4. Now we neeed to verify the update result and find a way to interact with a new contract.

```ts
const counterContractStateAfterUpdate = await blockchain
    .provider(initialCounterContract.address)
    .getState()
if (counterContractStateAfterUpdate.state.type !== "active") {
    throw new Error("Contract should be active after update")
}

// check that contract state is updated
expect(Cell.fromBoc(counterContractStateAfterUpdate.state.code!)[0]).toEqualCell(
    newCounterContractState.init?.code!,
)
expect(Cell.fromBoc(counterContractStateAfterUpdate.state.data!)[0]).toEqualCell(
    newCounterContractState.init?.data!,
)
```

And to interact with updated contract we can again use newly generated wrapper:

```ts
const updatedCounterContract = blockchain.openContract(
            CounterAfterUpdate.fromAddress(initialCounterContract.address),
        )

// now this action will decrease counter, since we've updated contract code
await updatedCounterContract.send(
    deployer.getSender(),
    {value: toNano("0.1")},
    {
        $$type: "CounterAction",
    },
)
```