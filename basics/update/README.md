# Updating a contract

In this example, we will modify the logic of the deployed contract by using the contract update functionality of TON Blockchain.

Note that updating a contract is a potentially dangerous operation that can lock funds within the contract or disrupt its expected behavior. You must also be extra cautious when updating a contract with child contract dependencies.

To handle recursive dependencies between parent and child contracts, e.g., if they require `StateInit` from each other, the Tact compiler creates a ref cell with the data of other contracts, which is used to resolve such dependencies. Therefore, if you want to update one of the contracts in this dependency chain, you will also need to update this reference cell correctly.

Now, let's perform a simple update of the counter contract.

1. We will deploy the initial counter contract:

```tact
contract CounterBeforeUpdate(
    data: Int as uint32,
    updateAuthority: Address,
) {
    receive(msg: CounterAction) {
        self.data += 1;
    }

    receive(msg: UpdateContractRequest) {
        require(sender() == self.updateAuthority, "Incorrect update authority");
        setData(msg.data);
        setCode(msg.code);
    }

    get fun data(): Int {
        return self.data;
    }
}
```

Its storage contains two fields: counter data and update authority. Upon receiving a `CounterAction` message, this contract increases its internal `data` variable.

2. We will prepare and compile the second counter contract:

```tact
contract CounterAfterUpdate(
    data: Int as uint32,
) {
    receive(msg: CounterAction) {
        self.data -= 1;
    }

    get fun data(): Int {
        return self.data;
    }
}
```

This contract has only one field, the integer `data` variable, which it now _decreases_ upon receiving the `CounterAction` message.

3. Now, we want to send the `UpdateContractRequest` message to the deployed contract to update its code and data. The message struct would look like this:

```tact
message(0xa7ffd45e) UpdateContractRequest {
    code: Cell;
    data: Cell;
}
```

In TypeScript, the most optimal way to create such a message is to use Tact's autogenerated wrapper for the `CounterAfterUpdate`. After initializing it with the needed parameters, we can extract its code and data:

```ts
import {CounterAfterUpdate} from "../output/UpdateContract_CounterAfterUpdate"
// ...
const firstCounterValue = await initialCounterContract.getData()

const newCounterContractState = await CounterAfterUpdate.fromInit(firstCounterValue)
const updateResult = await initialCounterContract.send(
    deployer.getSender(),
    {value: toNano("0.1")},
    {
        $$type: "UpdateContractRequest",
        code: newCounterContractState.init?.code!,
        data: newCounterContractState.init?.data!,
    },
)
```

4. Now we need to verify the update result and find a way to interact with the new contract.

```ts
const counterContractStateAfterUpdate = await blockchain
    .provider(initialCounterContract.address)
    .getState()
if (counterContractStateAfterUpdate.state.type !== "active") {
    throw new Error("Contract should be active after update")
}

// check that contract state is updated
expect(Cell.fromBoc(counterContractStateAfterUpdate.state.code!)[0]).toEqualCell(
    newCounterContractState.init?.code!,
)
expect(Cell.fromBoc(counterContractStateAfterUpdate.state.data!)[0]).toEqualCell(
    newCounterContractState.init?.data!,
)
```

To interact with the updated contract, we can again use the newly generated wrapper:

```ts
const updatedCounterContract = blockchain.openContract(
    CounterAfterUpdate.fromAddress(initialCounterContract.address),
)

// now this action will decrease the counter, since we've updated the contract code
await updatedCounterContract.send(
    deployer.getSender(),
    {value: toNano("0.1")},
    {
        $$type: "CounterAction",
    },
)
```
