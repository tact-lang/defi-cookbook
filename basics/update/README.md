# Updating a contract

In this example, we will use the TON contract update functionality to modify the logic of an already deployed contract.

Note that updating a contract is a potentially dangerous operation that can lock funds within the contract or disrupt the protocol.
You need to be extra careful when updating a contract with child-contract dependencies. To handle recursive dependencies between parent and child contracts (for example, if they require `initOf` from each other), the Tact compiler creates a ref cell with other contracts' data that is used to resolve such dependencies. So, if you want to update one of the contracts in this dependency chain, you will also need to correctly update this ref cell.

Nevertheless, let's see a simple update example for the counter contract.

1. We will deploy the initial counter contract:

```tact
contract CounterBeforeUpdate(
    data: Int as uint32,
    updateAuthority: Address,
) {
    receive(msg: CounterAction) {
        self.data += 1;
    }

    receive(msg: UpdateContractRequest) {
        require(sender() == self.updateAuthority, "Incorrect update authority");
        setData(msg.data);
        setCode(msg.code);
    }

    get fun data(): Int {
        return self.data;
    }
}
```

Its storage contains two fields: counter data and update authority. Upon receiving a `CounterAction` message, this contract increases its internal `data` variable.

2. We will prepare and compile the second counter contract:

```tact
contract CounterAfterUpdate(
    data: Int as uint32,
) {
    receive(msg: CounterAction) {
        self.data -= 1;
    }

    get fun data(): Int {
        return self.data;
    }
}
```

This contract has only one field, the integer `data` variable. Also, this contract _decreases_ the counter variable upon receiving the same `CounterAction` message.

3. Now we want to use the `UpdateContractRequest` message on the deployed contract to update its code and data. The message itself looks like this:

```tact
message(0xa7ffd45e) UpdateContractRequest {
    code: Cell;
    data: Cell;
}
```

The most optimal way to create such a message is to use the Tact autogenerated wrapper for `CounterAfterUpdate`. After initializing it with the needed parameters, we can extract code and data from it:

```ts
import {CounterAfterUpdate} from "../output/UpdateContract_CounterAfterUpdate"
// ...
const firstCounterValue = await initialCounterContract.getData()

const newCounterContractState = await CounterAfterUpdate.fromInit(firstCounterValue)
const updateResult = await initialCounterContract.send(
    deployer.getSender(),
    {value: toNano("0.1")},
    {
        $$type: "UpdateContractRequest",
        code: newCounterContractState.init?.code!,
        data: newCounterContractState.init?.data!,
    },
)
```

4. Now we need to verify the update result and find a way to interact with the new contract.

```ts
const counterContractStateAfterUpdate = await blockchain
    .provider(initialCounterContract.address)
    .getState()
if (counterContractStateAfterUpdate.state.type !== "active") {
    throw new Error("Contract should be active after update")
}

// check that contract state is updated
expect(Cell.fromBoc(counterContractStateAfterUpdate.state.code!)[0]).toEqualCell(
    newCounterContractState.init?.code!,
)
expect(Cell.fromBoc(counterContractStateAfterUpdate.state.data!)[0]).toEqualCell(
    newCounterContractState.init?.data!,
)
```

To interact with the updated contract, we can again use the newly generated wrapper:

```ts
const updatedCounterContract = blockchain.openContract(
    CounterAfterUpdate.fromAddress(initialCounterContract.address),
)

// now this action will decrease the counter, since we've updated the contract code
await updatedCounterContract.send(
    deployer.getSender(),
    {value: toNano("0.1")},
    {
        $$type: "CounterAction",
    },
)
```
